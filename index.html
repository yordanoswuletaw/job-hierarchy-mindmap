<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Job Hierarchy Mind Map</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            margin: 0;
            color: #333;
            font-size: 20px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .root-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .root-selector label {
            color: #333;
            font-weight: 500;
            font-size: 14px;
        }

        .root-selector select {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 6px;
            background: white;
            color: #333;
            font-size: 14px;
            cursor: pointer;
            min-width: 200px;
        }

        .root-selector select:focus {
            outline: none;
            border-color: #5a6fd8;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .control-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .control-btn:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .info {
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
            border-left: 3px solid #667eea;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            word-wrap: break-word;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
            z-index: 2000;
        }

        .loading h3 {
            margin: 0 0 15px 0;
            color: #333;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fee;
            color: #c33;
            padding: 30px;
            border-radius: 12px;
            border: 1px solid #fcc;
            text-align: center;
            z-index: 2000;
            max-width: 400px;
        }
 
        .error h3 {
            margin: 0 0 15px 0;
        }

        .error button {
            background: #c33;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 15px;
        }

        .error button:hover {
            background: #a22;
        }

        .link {
            fill: none;
            stroke: #c9c9c9;
            stroke-width: 1.5;
            opacity: 0.7;
            transition: all 0.2s ease;
        }

        .link:hover {
            stroke: #667eea;
            stroke-width: 2;
            opacity: 1;
        }

        .node-rect {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .node-rect:hover {
            filter: brightness(1.15) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
            transform: scale(1.05);
        }

        /* Subtle pulse for major families */
        @keyframes pulseGlow {
            0% { filter: brightness(1) saturate(1); }
            50% { filter: brightness(1.06) saturate(1.1); }
            100% { filter: brightness(1) saturate(1); }
        }
        .family-node .node-rect { animation: pulseGlow 4.5s ease-in-out infinite; }

        .node-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 11px;
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            fill: #333;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }

        .level-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 16px;
            font-weight: 700;
            text-anchor: middle;
            fill: #333;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.9);
        }

        .level-line {
            stroke: #e0e0e0;
            stroke-width: 2;
            opacity: 0.4;
        }

        .level-background {
            fill: none;
            stroke: #f5f5f5;
            stroke-width: 1;
            opacity: 0.3;
        }

        /* Level-based text sizes for visual hierarchy */
        .label-level-0 { font-size: 14px; font-weight: 700; }
        .label-level-1 { font-size: 13px; font-weight: 700; }
        .label-level-2 { font-size: 12px; font-weight: 600; }
        .label-level-3 { font-size: 11px; font-weight: 500; }
        .label-level-4, .label-level-5 { font-size: 10px; font-weight: 500; }

        /* Group nodes get a dashed outline */
        .group-node rect {
            stroke: #888;
            stroke-dasharray: 4 3;
            stroke-width: 1.5;
        }


        .no-data {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .no-data h3 {
            margin: 0 0 15px 0;
            color: #333;
        }

        .no-data p {
            color: #666;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Job Hierarchy Mind Map</h1>
        <div class="controls">
            <div class="root-selector">
                <label for="rootSelect">Select Job Category:</label>
                <select id="rootSelect" onchange="changeRoot()">
                    <option value="">Loading...</option>
                </select>
            </div>
            <div class="info">Click nodes to expand/collapse • Drag to pan • Scroll to zoom</div>
            <button class="control-btn" onclick="resetZoom()">Reset View</button>
            <button class="control-btn" onclick="expandAll()">Expand All</button>
            <button class="control-btn" onclick="collapseAll()">Collapse All</button>
        </div>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <h3>Loading Job Hierarchy Data...</h3>
        <p>Please wait while we process the data</p>
    </div>

    <div class="error" id="error" style="display: none;">
        <h3>Error Loading Data</h3>
        <p id="errorMessage"></p>
        <button onclick="location.reload()">Retry</button>
    </div>

    <div class="no-data" id="noData" style="display: none;">
        <h3>No Data Available</h3>
        <p>Please select a job category from the dropdown above</p>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Global variables and layout constants
        let data = null;
        let currentRoot = null;
        let svg = null;
        let g = null;
        let zoom = null;
        let expandedNodes = new Set();
        let sourceNodes = [];
        let layers = { levels: null, links: null, nodes: null };

        // Controls and layout constants
        const ALL_OPTION = '__ALL__';
        const GROUP_THRESHOLD = 40;        // If siblings exceed this, group alphabetically
        const GROUP_BUCKET_MAX = 25;       // Target max items per group bucket
        const NODE_H_SPACING = 380;        // Horizontal spacing per semantic level (wider)
        const NODE_V_SPACING = 50;         // Vertical spacing between nodes (slightly taller)
        const MARGIN = { top: 80, right: 140, bottom: 80, left: 220 };
        const LEVEL_NAMES = ['Job Taxonomy', 'Job Families', 'Job Functions', 'Roles', 'Specializations'];
        const ANIM_DURATION = 700;
        const ANIM_EASE = d3.easeCubicOut;
        let nodePositions = new Map();     // Persist node positions for smooth re-layout
        let firstRender = true;             // Stronger animation on first paint
        let clickAnimate = false;           // Stronger animation on node toggle

        // Initialize the application
        async function init() {
            try {
                // Load data
                const response = await fetch('job_title_graph.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                data = await response.json();
                
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                
                // Process data and populate dropdown
                processData();
                populateDropdown();
                
                // Default to full taxonomy view
                const select = document.getElementById('rootSelect');
                select.value = ALL_OPTION;
                changeRoot();
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('errorMessage').textContent = error.message;
                document.getElementById('error').style.display = 'block';
            }
        }

        // Process the job hierarchy data
        function processData() {
            if (data.source_nodes && Array.isArray(data.source_nodes)) {
                sourceNodes = data.source_nodes;
            }
        }

        // Populate the dropdown with source nodes
        function populateDropdown() {
            const select = document.getElementById('rootSelect');
            select.innerHTML = '';
            
            // Complete taxonomy option
            const allOpt = document.createElement('option');
            allOpt.value = ALL_OPTION;
            allOpt.textContent = 'All Job Families (Complete Taxonomy)';
            select.appendChild(allOpt);
            
            sourceNodes.forEach(node => {
                const option = document.createElement('option');
                option.value = node;
                option.textContent = node;
                select.appendChild(option);
            });
        }

        // Change the root node and update visualization
        function changeRoot() {
            const select = document.getElementById('rootSelect');
            const selectedValue = select.value;
            
            console.log('Changing root to:', selectedValue);
            
            // Create root and build tree
            if (selectedValue === ALL_OPTION) {
                // Full taxonomy view with virtual root
                currentRoot = {
                    id: 'Job Taxonomy',
                    path: 'Job Taxonomy',
                    name: 'Job Taxonomy',
                    semanticLevel: 0,
                    children: []
                };
                // Allow initial expansion for first two levels
                expandedNodes = new Set(['Job Taxonomy']);
                sourceNodes.forEach(family => {
                    const child = makeNode(currentRoot, family, 1);
                    currentRoot.children.push(child);
                    buildTree(child, family, 2);
                    // Expand families by default
                    expandedNodes.add(child.id);
                });
            } else {
                // Focus on a single family
                currentRoot = {
                    id: selectedValue,
                    path: selectedValue,
                    name: selectedValue,
                    semanticLevel: 1,
                    children: []
                };
                expandedNodes = new Set([selectedValue]);
                buildTree(currentRoot, selectedValue, 2);
            }

            // Create or update visualization
            if (svg) {
                svg.remove();
            }
            createVisualization();
        }

        // Recursively build the tree structure
        function buildTree(parentNode, nodeName, semanticLevel) {
            if (!data.adjacency_list || !data.adjacency_list[nodeName]) {
                return;
            }

            const rawChildren = data.adjacency_list[nodeName];
            if (!Array.isArray(rawChildren) || rawChildren.length === 0) return;

            // Deduplicate while preserving order
            const seen = new Set();
            const children = [];
            for (const childName of rawChildren) {
                const displayName = childName === null ? '[N/A]' : String(childName);
                if (!seen.has(displayName)) {
                    seen.add(displayName);
                    children.push(displayName);
                }
            }

            // If there are many children, group them alphabetically
            if (children.length > GROUP_THRESHOLD) {
                const groups = makeAlphabeticalGroups(children);
                for (const group of groups) {
                    const groupNode = {
                        id: parentNode.id + '::grp::' + group.label,
                        path: parentNode.path + '/grp-' + group.label,
                        name: group.label,
                        semanticLevel: semanticLevel - 0.5, // placed between parent and children for spacing
                        isGroup: true,
                        children: []
                    };
                    parentNode.children.push(groupNode);
                    for (const name of group.items) {
                        const childNode = makeNode(groupNode, name, semanticLevel);
                        groupNode.children.push(childNode);
                        if (data.adjacency_list[name]) {
                            buildTree(childNode, name, semanticLevel + 1);
                        }
                    }
                }
            } else {
                for (const name of children) {
                    const childNode = makeNode(parentNode, name, semanticLevel);
                    parentNode.children.push(childNode);
                    if (data.adjacency_list[name]) {
                        buildTree(childNode, name, semanticLevel + 1);
                    }
                }
            }
        }

        // Create a child node with a unique path-based id
        function makeNode(parentNode, name, semanticLevel) {
            const safeName = String(name).replace(/\s+/g, ' ').trim();
            const path = (parentNode.path ? parentNode.path + '/' : '') + safeName;
            return {
                id: path,
                path,
                name: safeName,
                semanticLevel,
                children: []
            };
        }

        // Create groups of names by letter ranges, targeting ~GROUP_BUCKET_MAX items per group
        function makeAlphabeticalGroups(items) {
            const map = new Map();
            for (const name of items.slice().sort((a,b) => a.localeCompare(b))) {
                const m = name.match(/[A-Za-z]/);
                const letter = m ? m[0].toUpperCase() : '#';
                if (!map.has(letter)) map.set(letter, []);
                map.get(letter).push(name);
            }
            const letters = Array.from(map.keys()).sort();
            const groups = [];
            let current = [];
            let currentCount = 0;
            let startLetter = null;
            for (const letter of letters) {
                const list = map.get(letter);
                if (currentCount > 0 && currentCount + list.length > GROUP_BUCKET_MAX) {
                    const label = current.length === 1 ? current[0] : (startLetter + '–' + current[current.length - 1]);
                    groups.push({ label, items: current.flatMap(l => map.get(l)) });
                    current = [];
                    currentCount = 0;
                    startLetter = null;
                }
                if (current.length === 0) startLetter = letter;
                current.push(letter);
                currentCount += list.length;
            }
            if (current.length > 0) {
                const label = current.length === 1 ? current[0] : (startLetter + '–' + current[current.length - 1]);
                groups.push({ label, items: current.flatMap(l => map.get(l)) });
            }
            return groups;
        }

        // Create the D3 visualization
        function createVisualization() {
            if (!currentRoot) return;

            const width = window.innerWidth;
            const height = window.innerHeight - 45;

            svg = d3.select('body')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', 'transparent');

            // Create zoom behavior
            zoom = d3.zoom()
                .scaleExtent([0.2, 3])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Create main group for visualization, with margins
            g = svg.append('g')
                .attr('transform', `translate(${MARGIN.left},${MARGIN.top})`);

            // Layer groups to enable transitions without full re-render wipes
            layers.levels = g.append('g').attr('class', 'levels');
            layers.links = g.append('g').attr('class', 'links');
            layers.nodes = g.append('g').attr('class', 'nodes');

            firstRender = true;
            updateVisualization();

            window.addEventListener('resize', () => {
                if (svg) {
                    const newWidth = window.innerWidth;
                    const newHeight = window.innerHeight - 45;
                    svg.attr('width', newWidth).attr('height', newHeight);
                    updateVisualization();
                }
            });
        }

        // Update the visualization
        function updateVisualization() {
            if (!currentRoot) return;

            // Clear and redraw level guides only (nodes/links use data joins for animation)
            layers.levels.selectAll('*').remove();

            // Create hierarchy layout
            const root = d3.hierarchy(currentRoot);

            // Apply collapse state according to expandedNodes
            root.descendants().forEach(d => {
                const hasChildren = d.data.children && d.data.children.length > 0;
                if (hasChildren && !expandedNodes.has(d.data.id)) {
                    // Collapse by hiding children for layout
                    d.children = null;
                }
            });

            // Tree layout (left-to-right)
            const tree = d3.tree()
                .nodeSize([NODE_V_SPACING, NODE_H_SPACING])
                .separation((a, b) => (a.parent === b.parent ? 1.2 : 1.6));
            tree(root);

            // Position horizontally by semantic level, with group nodes offset by 0.5
            root.each(n => {
                const offset = n.data && n.data.isGroup ? 0.5 : 0;
                const sem = (n.data && typeof n.data.semanticLevel === 'number') ? n.data.semanticLevel : n.depth;
                n.y = (sem + offset) * NODE_H_SPACING;
            });

            const nodes = root.descendants();
            const links = root.links();

            // Transition settings
            const ease = (firstRender || clickAnimate) ? d3.easeElasticOut : ANIM_EASE;
            const duration = (firstRender || clickAnimate) ? 950 : ANIM_DURATION;

            // Level guides and labels (based on integer semantic levels present)
            const maxSemLevel = d3.max(nodes, d => Math.floor(d.data.semanticLevel || 0));
            const levelGroup = layers.levels;
            for (let l = 0; l <= maxSemLevel; l++) {
                const x = l * NODE_H_SPACING;
                levelGroup.append('line')
                    .attr('class', 'level-line')
                    .attr('x1', x)
                    .attr('y1', -40)
                    .attr('x2', x)
                    .attr('y2', window.innerHeight - MARGIN.top - MARGIN.bottom)
                    .attr('stroke', '#e0e0e0')
                    .attr('opacity', 0.35);
                levelGroup.append('text')
                    .attr('class', 'level-label')
                    .attr('x', x)
                    .attr('y', -48)
                    .attr('text-anchor', 'middle')
                    .text(LEVEL_NAMES[l] || ('Level ' + l));
            }

            // Links
            const linkGen = d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x);

            const linkSel = layers.links
                .attr('fill', 'none')
                .attr('stroke', '#c9c9c9')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 1.5)
                .selectAll('path.link')
                .data(links, d => d.target.data.id);

            // EXIT
            linkSel.exit()
                .transition().duration(ANIM_DURATION).ease(ANIM_EASE)
                .attr('stroke-opacity', 0)
                .remove();

            // ENTER
            const linkEnter = linkSel.enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d => {
                    const sPrev = getPrevPos(d.source);
                    const tPrev = getPrevPos(d.target);
                    return linkGen({ source: sPrev, target: sPrev });
                });

            // UPDATE + ENTER MERGE (solid growth, no dash)
            linkEnter.merge(linkSel)
                .transition().duration(duration).ease(ease)
                .delay(d => Math.min(400, (d.target.depth || 0) * 60))
                .attrTween('d', function(d) {
                    const sPrev = getPrevPos(d.source);
                    const tPrev = getPrevPos(d.target);
                    const ix = d3.interpolateNumber(sPrev.x, d.source.x);
                    const iy = d3.interpolateNumber(sPrev.y, d.source.y);
                    const jx = d3.interpolateNumber(tPrev.x, d.target.x);
                    const jy = d3.interpolateNumber(tPrev.y, d.target.y);
                    return t => linkGen({ source: { x: ix(t), y: iy(t) }, target: { x: jx(t), y: jy(t) } });
                })
                .attr('stroke-opacity', 0.75);

            // Nodes
            const nodeSel = layers.nodes
                .selectAll('g.node')
                .data(nodes, d => d.data.id);

            // EXIT
            nodeSel.exit()
                .transition().duration(ANIM_DURATION).ease(ANIM_EASE)
                .style('opacity', 0)
                .attr('transform', d => `translate(${d.y + 20},${d.x}) scale(0.98)`)
                .remove();

            // ENTER
            const nodeEnter = nodeSel.enter()
                .append('g')
                .attr('class', d => 'node' + (d.data.isGroup ? ' group-node' : '') + (Math.floor(d.data.semanticLevel || 0) === 1 ? ' family-node' : ''))
                .attr('transform', d => {
                    const p = getPrevPos(d);
                    return `translate(${p.y - 60},${p.x}) scale(0.9)`;
                })
                .style('opacity', 0)
                .on('click', (event, d) => toggleNode(d));

            nodeEnter.append('rect')
                .attr('class', 'node-rect')
                .attr('width', d => getNodeWidth(d))
                .attr('height', d => getNodeHeight(d))
                .attr('x', d => -getNodeWidth(d) / 2)
                .attr('y', d => -getNodeHeight(d) / 2)
                .attr('rx', d => Math.min(14, getNodeHeight(d) / 2))
                .attr('ry', d => Math.min(14, getNodeHeight(d) / 2))
                .attr('fill', d => getNodeColor(d))
                .attr('stroke', d => d.data.isGroup ? '#888' : 'none');

            nodeEnter.append('text')
                .attr('class', d => 'node-label label-level-' + (d.data.semanticLevel != null ? Math.floor(d.data.semanticLevel) : d.depth))
                .attr('dy', '0.35em')
                .attr('text-anchor', 'middle')
                .style('fill', '#333')
                .text(d => truncateText(formatLabel(d.data.name), 28))
                .append('title')
                .text(d => d.data.name);

            // UPDATE + ENTER MERGE
            nodeEnter.merge(nodeSel)
                .transition().duration(duration).ease(ease)
                .delay(d => Math.min(500, (d.depth || 0) * 70))
                .style('opacity', 1)
                .attr('transform', d => `translate(${d.y},${d.x}) scale(1)`);

            // Persist positions for next transition
            nodePositions.clear();
            root.each(n => nodePositions.set(n.data.id, { x: n.x, y: n.y }));

            // Reset animation flags
            firstRender = false;
            clickAnimate = false;
        }

        // Previous position helper for smooth transitions
        function getPrevPos(n) {
            if (!n) return { x: 0, y: 0 };
            const prev = nodePositions.get(n.data.id);
            if (prev) return prev;
            if (n.parent) {
                const pPrev = nodePositions.get(n.parent.data.id);
                if (pPrev) return pPrev;
            }
            return { x: n.x || 0, y: n.y || 0 };
        }

        // Get node width based on level
        function getNodeWidth(d) {
            const sem = Math.floor(d.data.semanticLevel || 0);
            if (sem === 0) return 220;
            if (sem === 1) return 180;
            if (sem === 2) return 160;
            if (sem === 3) return 140;
            return 130;
        }

        // Get node height based on level
        function getNodeHeight(d) {
            const sem = Math.floor(d.data.semanticLevel || 0);
            if (sem === 0) return 36;
            if (sem === 1) return 32;
            if (sem === 2) return 28;
            if (sem === 3) return 26;
            return 24;
        }

        // Get node color based on level
        function getNodeColor(d) {
            const sem = Math.floor(d.data.semanticLevel || 0);
            const palette = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#43e97b', '#fa7090', '#fee140'];
            const base = palette[Math.min(sem, palette.length - 1)];
            // Slightly lighten group nodes
            if (d.data.isGroup) return d3.color(base).brighter(0.8).formatHex();
            return base;
        }

        // Toggle node expansion/collapse
        function toggleNode(d) {
            const id = d.data.id;
            if (!id) return;
            if (expandedNodes.has(id)) {
                expandedNodes.delete(id);
            } else {
                expandedNodes.add(id);
            }
            clickAnimate = true; // stronger animation on interaction
            updateVisualization();
        }

        // Show tooltip
        function showTooltip(event, d) {
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .text(d.data.name);
        }

        // Hide tooltip
        function hideTooltip() {
            d3.selectAll('.tooltip').remove();
        }

        // Truncate text for display
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            
            // Try to break at word boundaries for better readability
            const words = text.split(' ');
            let result = '';
            
            for (let word of words) {
                if ((result + ' ' + word).length <= maxLength) {
                    result += (result ? ' ' : '') + word;
                } else {
                    break;
                }
            }
            
            if (result.length === 0) {
                // If no words fit, truncate with ellipsis
                return text.substring(0, maxLength - 3) + '...';
            }
            
            // If we have a result but it's much shorter than maxLength, try to fit more
            if (result.length < maxLength - 10) {
                // Try to fit one more word if it's not too long
                for (let word of words) {
                    if (result.includes(word)) continue; // Skip if already included
                    if ((result + ' ' + word).length <= maxLength) {
                        result += ' ' + word;
                    } else {
                        break;
                    }
                }
            }
            
            return result + '...';
        }

        // Remove verbose parenthetical phrases for display when helpful
        function formatLabel(text) {
            const t = String(text);
            if (t.length <= 28) return t;
            const noParen = t.replace(/\s*\([^\)]*\)\s*/g, ' ').replace(/\s{2,}/g, ' ').trim();
            return noParen.length > 0 ? noParen : t;
        }

        // Control functions
        function resetZoom() {
            if (svg && zoom) {
                svg.transition().duration(750).call(
                    zoom.transform,
                    d3.zoomIdentity.translate(MARGIN.left, MARGIN.top)
                );
            }
        }

        function expandAll() {
            if (!currentRoot) return;
            expandedNodes.clear();
            const hierarchy = d3.hierarchy(currentRoot);
            hierarchy.descendants().forEach(d => {
                if (d.data.children && d.data.children.length > 0) {
                    expandedNodes.add(d.data.id);
                }
            });
            updateVisualization();
        }

        function collapseAll() {
            expandedNodes.clear();
            // Keep root expanded
            if (currentRoot && currentRoot.id) expandedNodes.add(currentRoot.id);
            updateVisualization();
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
