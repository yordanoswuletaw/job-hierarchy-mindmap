<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Job Hierarchy Mind Map</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            margin: 0;
            color: #333;
            font-size: 20px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .root-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .root-selector label {
            color: #333;
            font-weight: 500;
            font-size: 14px;
        }

        .root-selector select {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 6px;
            background: white;
            color: #333;
            font-size: 14px;
            cursor: pointer;
            min-width: 200px;
        }

        .root-selector select:focus {
            outline: none;
            border-color: #5a6fd8;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .control-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .control-btn:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .info {
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
            border-left: 3px solid #667eea;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            word-wrap: break-word;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
            z-index: 2000;
        }

        .loading h3 {
            margin: 0 0 15px 0;
            color: #333;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fee;
            color: #c33;
            padding: 30px;
            border-radius: 12px;
            border: 1px solid #fcc;
            text-align: center;
            z-index: 2000;
            max-width: 400px;
        }

        .error h3 {
            margin: 0 0 15px 0;
        }

        .error button {
            background: #c33;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 15px;
        }

        .error button:hover {
            background: #a22;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5;
            opacity: 0.7;
            transition: all 0.2s ease;
        }

        .link:hover {
            stroke: #667eea;
            stroke-width: 2;
            opacity: 1;
        }

        .node-rect {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .node-rect:hover {
            filter: brightness(1.15) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
            transform: scale(1.05);
        }

        .node-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 11px;
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            fill: #333;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }

        .level-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 16px;
            font-weight: 700;
            text-anchor: middle;
            fill: #333;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.9);
        }

        .level-line {
            stroke: #e0e0e0;
            stroke-width: 2;
            opacity: 0.4;
        }

        .level-background {
            fill: none;
            stroke: #f5f5f5;
            stroke-width: 1;
            opacity: 0.3;
        }


        .no-data {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .no-data h3 {
            margin: 0 0 15px 0;
            color: #333;
        }

        .no-data p {
            color: #666;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Job Hierarchy Mind Map</h1>
        <div class="controls">
            <div class="root-selector">
                <label for="rootSelect">Select Job Category:</label>
                <select id="rootSelect" onchange="changeRoot()">
                    <option value="">Loading...</option>
                </select>
            </div>
            <div class="info">Click nodes to expand/collapse • Drag to pan • Scroll to zoom</div>
            <button class="control-btn" onclick="resetZoom()">Reset View</button>
            <button class="control-btn" onclick="expandAll()">Expand All</button>
            <button class="control-btn" onclick="collapseAll()">Collapse All</button>
        </div>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <h3>Loading Job Hierarchy Data...</h3>
        <p>Please wait while we process the data</p>
    </div>

    <div class="error" id="error" style="display: none;">
        <h3>Error Loading Data</h3>
        <p id="errorMessage"></p>
        <button onclick="location.reload()">Retry</button>
    </div>

    <div class="no-data" id="noData" style="display: none;">
        <h3>No Data Available</h3>
        <p>Please select a job category from the dropdown above</p>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Global variables
        let data = null;
        let currentRoot = null;
        let svg = null;
        let g = null;
        let zoom = null;
        let nodes = [];
        let links = [];
        let nodeMap = new Map();
        let expandedNodes = new Set();
        let sourceNodes = [];

        // Initialize the application
        async function init() {
            try {
                // Load data
                const response = await fetch('job_title_graph.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                data = await response.json();
                
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                
                // Process data and populate dropdown
                processData();
                populateDropdown();
                
                // Show no data message initially
                document.getElementById('noData').style.display = 'block';
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('errorMessage').textContent = error.message;
                document.getElementById('error').style.display = 'block';
            }
        }

        // Process the job hierarchy data
        function processData() {
            if (data.source_nodes && Array.isArray(data.source_nodes)) {
                sourceNodes = data.source_nodes;
            }
        }

        // Populate the dropdown with source nodes
        function populateDropdown() {
            const select = document.getElementById('rootSelect');
            select.innerHTML = '<option value="">Select a job category...</option>';
            
            sourceNodes.forEach(node => {
                const option = document.createElement('option');
                option.value = node;
                option.textContent = node;
                select.appendChild(option);
            });
        }

        // Change the root node and update visualization
        function changeRoot() {
            const select = document.getElementById('rootSelect');
            const selectedValue = select.value;
            
            console.log('Changing root to:', selectedValue);
            
            if (!selectedValue) {
                // Hide visualization, show no data message
                if (svg) svg.remove();
                svg = null;
                document.getElementById('noData').style.display = 'block';
                return;
            }

            // Hide no data message
            document.getElementById('noData').style.display = 'none';
            
            // Create new root node for the selected category
            currentRoot = {
                id: selectedValue,
                name: selectedValue,
                level: 0,
                children: []
            };
            
            console.log('Created root node:', currentRoot);
            
            // Build the tree for this root
            buildTree(currentRoot, selectedValue, 1);
            
            console.log('Final tree structure:', currentRoot);
            
            // Create or update visualization
            if (svg) {
                svg.remove();
            }
            createVisualization();
        }

        // Recursively build the tree structure
        function buildTree(parentNode, nodeName, level) {
            if (!data.adjacency_list || !data.adjacency_list[nodeName]) {
                console.log(`No children found for: ${nodeName}`);
                return;
            }

            const children = data.adjacency_list[nodeName];
            console.log(`Building tree for ${nodeName} with ${children.length} children:`, children);
            
            if (Array.isArray(children)) {
                children.forEach(childName => {
                    // Handle null values as terminal nodes
                    const displayName = childName === null ? "[N/A]" : childName;
                    const childNode = {
                        id: displayName,
                        name: displayName,
                        level: level,
                        children: []
                    };
                    
                    parentNode.children.push(childNode);
                    
                    // Recursively build children if they exist in adjacency list
                    if (childName !== null && data.adjacency_list[childName]) {
                        buildTree(childNode, childName, level + 1);
                    }
                });
            }
            
            console.log(`Finished building tree for ${nodeName}, total children: ${parentNode.children.length}`);
        }

        // Create the D3 visualization
        function createVisualization() {
            if (!currentRoot) return;

            // Set up SVG - use the absolute maximum screen space
            const width = window.innerWidth;
            const height = window.innerHeight - 45; // Minimal header height for maximum graph space

            svg = d3.select('body')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', 'transparent');

            // Create zoom behavior
            zoom = d3.zoom()
                .scaleExtent([0.1, 5])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Create main group for visualization
            g = svg.append('g');

            // Create initial visualization
            updateVisualization();

            // Handle window resize
            window.addEventListener('resize', () => {
                if (svg) {
                    const newWidth = window.innerWidth;
                    const newHeight = window.innerHeight - 45;
                    svg.attr('width', newWidth).attr('height', newHeight);
                    updateVisualization();
                }
            });
        }

        // Update the visualization
        function updateVisualization() {
            if (!currentRoot) return;

            // Clear existing elements
            g.selectAll('*').remove();

            // Debug: Log the current root
            console.log('Current root:', currentRoot);

            // Create hierarchy layout
            const hierarchy = d3.hierarchy(currentRoot);
            
            // Debug: Log the hierarchy
            console.log('Hierarchy:', hierarchy);
            
            // Apply initial collapse state
            hierarchy.descendants().forEach(d => {
                if (d.data.level > 1 && !expandedNodes.has(d.data.id)) {
                    d.children = null;
                }
            });

            // Create a force simulation for dynamic positioning
            const nodes = hierarchy.descendants();
            const links = hierarchy.links();

            // Set up force simulation for side-view layout with wide level separation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-150))
                .force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
                .force('collision', d3.forceCollide().radius(d => Math.max(getNodeWidth(d), getNodeHeight(d)) / 2 + 40))
                .force('x', d3.forceX().strength(0.95).x(d => {
                    // Much wider horizontal separation between levels
                    return 80 + d.depth * 450;
                }))
                .force('y', d3.forceY().strength(0.2).y(d => {
                    // Distribute nodes vertically within their level
                    return window.innerHeight / 2;
                }))
                .force('level', d3.forceY().strength(0.6).y(d => {
                    // Strong force to keep nodes at their level with better distribution
                    const levelHeight = (window.innerHeight - 120) / Math.max(1, d.depth + 1);
                    return 60 + (d.depth * levelHeight) + (levelHeight / 2);
                }));

            // Create links
            const link = g.selectAll('.link')
                .data(links)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 2)
                .attr('fill', 'none')
                .attr('opacity', 0.6);

            // Create nodes
            const node = g.selectAll('.node')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Add rounded rectangle nodes
            node.append('rect')
                .attr('class', 'node-rect')
                .attr('width', d => getNodeWidth(d))
                .attr('height', d => getNodeHeight(d))
                .attr('x', d => -getNodeWidth(d) / 2)
                .attr('y', d => -getNodeHeight(d) / 2)
                .attr('rx', d => getNodeHeight(d) / 2)
                .attr('ry', d => getNodeHeight(d) / 2)
                .attr('fill', d => getNodeColor(d))
                .attr('stroke', 'none')
                .attr('stroke-width', 0)
                .on('click', (event, d) => toggleNode(d))
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip);

            // Add node labels
            node.append('text')
                .attr('class', 'node-label')
                .attr('dy', '0.35em')
                .attr('text-anchor', 'middle')
                .text(d => truncateText(d.data.name, 35))
                .style('font-size', '12px')
                .style('font-weight', '500')
                .style('fill', '#333');

            // Add visual level indicators for better hierarchy understanding
            const levelGroups = g.selectAll('.level-group')
                .data(Array.from(new Set(nodes.map(d => d.depth))))
                .enter()
                .append('g')
                .attr('class', 'level-group');

            // Add level labels with wider spacing
            levelGroups.append('text')
                .attr('class', 'level-label')
                .attr('x', d => 80 + d * 450)
                .attr('y', 40)
                .attr('text-anchor', 'middle')
                .attr('fill', '#333')
                .attr('font-size', '16px')
                .attr('font-weight', '700')
                .text(d => {
                    if (d === 0) return 'ROOT LEVEL';
                    if (d === 1) return 'FIRST LEVEL';
                    if (d === 2) return 'SECOND LEVEL';
                    if (d === 3) return 'THIRD LEVEL';
                    return `LEVEL ${d}`;
                });

            // Add prominent level background lines with wider spacing
            levelGroups.append('line')
                .attr('class', 'level-line')
                .attr('x1', d => 80 + d * 450)
                .attr('y1', 50)
                .attr('x2', d => 80 + d * 450)
                .attr('y2', window.innerHeight - 60)
                .attr('stroke', '#e0e0e0')
                .attr('stroke-width', 2)
                .attr('opacity', 0.4);

            // Add level background rectangles for better visual separation
            levelGroups.append('rect')
                .attr('class', 'level-background')
                .attr('x', d => 80 + d * 450 - 200)
                .attr('y', 55)
                .attr('width', 400)
                .attr('height', window.innerHeight - 115)
                .attr('fill', 'none')
                .attr('stroke', '#f5f5f5')
                .attr('stroke-width', 1)
                .attr('opacity', 0.3);

            // Update positions on each tick
            simulation.on('tick', () => {
                link.attr('d', d => {
                    // Create clear, smooth links that show hierarchy flow
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    
                    // Use cubic bezier curves for smoother connections
                    const controlPoint1X = d.source.x + dx * 0.3;
                    const controlPoint1Y = d.source.y;
                    const controlPoint2X = d.target.x - dx * 0.3;
                    const controlPoint2Y = d.target.y;
                    
                    return `M${d.source.x},${d.source.y} C${controlPoint1X},${controlPoint1Y} ${controlPoint2X},${controlPoint2Y} ${d.target.x},${d.target.y}`;
                });

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            // Debug: Add a background rectangle to see the SVG area
            svg.insert('rect', ':first-child')
                .attr('width', window.innerWidth)
                .attr('height', window.innerHeight - 45)
                .attr('fill', 'rgba(255, 255, 255, 0.02)')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1);
        }

        // Get node width based on level
        function getNodeWidth(d) {
            if (d.data.level === 0) return 180; // Root node - wider for longer text
            if (d.data.level === 1) return 160; // First level - wider
            if (d.data.level === 2) return 140; // Second level - wider
            if (d.data.level === 3) return 130; // Third level - wider
            return 120; // Other levels - wider
        }

        // Get node height based on level
        function getNodeHeight(d) {
            if (d.data.level === 0) return 40; // Root node - taller for better text fit
            if (d.data.level === 1) return 36; // First level - taller
            if (d.data.level === 2) return 32; // Second level - taller
            if (d.data.level === 3) return 30; // Third level - taller
            return 28; // Other levels - taller
        }

        // Get node color based on level
        function getNodeColor(d) {
            if (d.data.level === 0) return '#667eea'; // Root - Blue
            if (d.data.level === 1) return '#764ba2'; // First level - Purple
            if (d.data.level === 2) return '#f093fb'; // Second level - Pink
            if (d.data.level === 3) return '#f5576c'; // Third level - Red
            if (d.data.level === 4) return '#4facfe'; // Fourth level - Light Blue
            if (d.data.level === 5) return '#43e97b'; // Fifth level - Green
            if (d.data.level === 6) return '#fa7090'; // Sixth level - Rose
            if (d.data.level === 7) return '#fee140'; // Seventh level - Yellow
            if (d.data.level === 8) return '#a8edea'; // Eighth level - Teal
            if (d.data.level === 9) return '#fed6e3'; // Ninth level - Light Pink
            return '#d299c2'; // Default - Lavender
        }

        // Toggle node expansion/collapse
        function toggleNode(d) {
            if (d.children) {
                // Collapse
                d.children = null;
                expandedNodes.delete(d.data.id);
            } else if (d.data.children && d.data.children.length > 0) {
                // Expand
                expandedNodes.add(d.data.id);
            }
            updateVisualization();
        }

        // Show tooltip
        function showTooltip(event, d) {
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .text(d.data.name);
        }

        // Hide tooltip
        function hideTooltip() {
            d3.selectAll('.tooltip').remove();
        }

        // Truncate text for display
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            
            // Try to break at word boundaries for better readability
            const words = text.split(' ');
            let result = '';
            
            for (let word of words) {
                if ((result + ' ' + word).length <= maxLength) {
                    result += (result ? ' ' : '') + word;
                } else {
                    break;
                }
            }
            
            if (result.length === 0) {
                // If no words fit, truncate with ellipsis
                return text.substring(0, maxLength - 3) + '...';
            }
            
            // If we have a result but it's much shorter than maxLength, try to fit more
            if (result.length < maxLength - 10) {
                // Try to fit one more word if it's not too long
                for (let word of words) {
                    if (result.includes(word)) continue; // Skip if already included
                    if ((result + ' ' + word).length <= maxLength) {
                        result += ' ' + word;
                    } else {
                        break;
                    }
                }
            }
            
            return result + '...';
        }

        // Control functions
        function resetZoom() {
            if (svg && zoom) {
                svg.transition().duration(750).call(
                    zoom.transform,
                    d3.zoomIdentity
                );
            }
        }

        function expandAll() {
            if (!currentRoot) return;
            expandedNodes.clear();
            const hierarchy = d3.hierarchy(currentRoot);
            hierarchy.descendants().forEach(d => {
                if (d.data.children && d.data.children.length > 0) {
                    expandedNodes.add(d.data.id);
                }
            });
            updateVisualization();
        }

        function collapseAll() {
            expandedNodes.clear();
            updateVisualization();
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
